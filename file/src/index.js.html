<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/index.js | tile-tools</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Easily create and modify tiles in an immutable way"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="tile-tools"><meta property="twitter:description" content="Easily create and modify tiles in an immutable way"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/magnonellie/tile-tools"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createTileArea">createTileArea</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fillTileAreaAt">fillTileAreaAt</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getTile">getTile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getTileAreaSlice">getTileAreaSlice</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getTileIndex">getTileIndex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getTilingTileData">getTilingTileData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mergeTileAreas">mergeTileAreas</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * Creates a vanilla JavaScript object which represents a tile area.
 *
 * @param {number} width - The width of the created tile area.
 * @param {number} height - The height of the created tile area.
 * @param {[]} tiles - The tiles of the tile area in a 1d array.
 *
 * @returns {Object} - The created tile area object.
 * @property {number} width - The width of the created tile area.
 * @property {number} height - The height of the created tile area.
 * @property {[]} tiles - The tiles of the created tile area.
 */
export function createTileArea(width, height, tiles) {
    if (width * height !== tiles.length) {
        throw new RangeError(&quot;The width and height doesn&apos;t match the amount of tiles given.&quot;);
    }

    return {
        width, height, tiles
    };
}

/**
 * Gets the index of a tile in the tile array from a position.
 *
 * @param {Object} area - The tile area to execute the operation on.
 * @param {number} x - The x coordinate of the tile.
 * @param {number} y - The y coordinate of the tile.
 *
 * @returns {number} The index of the tile in the main array.
 */
export function getTileIndex(area, x, y) {
    if (!inRange(area, x, y)) throw new RangeError();

    return y * area.width + x;
}

/**
 * Gets the tile at a position.
 *
 * @param {Object} area - The tile area to execute the operation on.
 * @param {number} x - The x coordinate of the tile.
 * @param {number} y - The y coordinate of the tile.
 *
 * @returns {Object} The tile at the provided position.
 */
export function getTile(area, x, y) {
    return { ...area.tiles[getTileIndex(area, x, y)] };
}

/**
 * Gets a spliced area from a tile area.
 *
 * If the requested area is outside the tile area, empty tiles will be generated.
 *
 * @param {Object} area - The tile area to execute the operation on.
 * @param {number} x - The x coordinate of the tile area.
 * @param {number} y - The y coordinate of the tile area.
 * @param {number} width - The width of the tile area.
 * @param {number} height - The height of the tile area.
 *
 * @returns {Object} - The tile area requested as a plain object.
 * @property {number} width - The width of the requested tile area.
 * @property {number} height - The height of the requested tile area.
 * @property {[]} tiles - The tiles of the requested tile area.
 */
export function getTileAreaSlice(area, x, y, width, height) {
    if (width &lt;= 0 || height &lt;= 0) throw new RangeError();

    const tiles = [];
    for (let ly = y; ly &lt; y + height; ly++) {
        for (let lx = x; lx &lt; x + width; lx++) {
            if (!inRange(area, lx, ly, 1, 1)) tiles.push(emptyTile());
            else tiles.push(getTile(area, lx, ly));
        }
    }
    return createTileArea(width, height, tiles);
}

/**
 * Gets tiling data from a tile area.
 *
 * Most of the time when mapping tilemaps, having the pen be &quot;tiling&quot; is more
 * useful than having it overwrite everywhere. This function provides
 * that kind of functionallity.
 *
 * @param {Object} area - The tile area to execute the operation on.
 * @param {number} originX - The x coordinate to tile from.
 * @param {number} originY - The y coordinate to tile from.
 * @param {number} x - The x coordinate to get data from.
 * @param {number} y - The y coordinate to get data from.
 *
 * @returns {Object} The calculated tile.
 */
export function getTilingTileData(area, originX, originY, x, y) {
    const { width, height } = area;
    const tileX = ((x - originX) % width + width) % width;
    const tileY = ((y - originY) % height + height) % height;

    return { ...getTile(area, tileX, tileY) };
}

/**
 * Merges two tile areas together, putting the second one on top of the first one.
 *
 * The merge does not fail if it goes outside of the tile area.
 *
 * @param {Object} area1 - The tile area to use as the base.
 * @param {Object} area2 - The tile area to put on top of the first tile area.
 * @param {number} x - The x coordinate of where to put the second area relative to the first area.
 * @param {number} y - The y coordinate of where to put the second area relative to the first area.
 * @param {boolean} skipEmpty - If the insertion should skip empty (-1) tiles.
 */
export function mergeTileAreas(area1, area2, x, y, skipEmpty) {
    const newTiles = [...area1.tiles];

    for (let lx = x; lx &lt; x + area2.width; lx++) {
        for (let ly = y; ly &lt; y + area2.height; ly++) {
            try {
                const newTile = getTile(area2, lx - x, ly - y);
                if (skipEmpty &amp;&amp; newTile.tileId === -1) continue;

                const index = getTileIndex(area1, lx, ly);
                newTiles[index] = { ...newTile };
            } catch (e) {
                if (e instanceof RangeError) continue;
                else throw e;
            }
        }
    }

    return createTileArea(area1.width, area1.height, newTiles);
}

/**
 * Fills an area (think bucket tool in an image manipulation program).
 *
 * @param {Object} area - The tile area to execute the operation on.
 * @param {number} x - The x coordinate of where to fill from.
 * @param {number} y - The y coordinate of where to fill from.
 * @param {Object} fillArea - The tile area to use for the fill.
 */
export function fillTileAreaAt(area, x, y, fillArea) {
    let positions = [];

    const fillTile = { ...getTile(area, x, y) };
    const seeds = [{ x, y }];

    const equal = (tile1, tile2) =&gt;
        tile1.tileId === tile2.tileId &amp;&amp;
        tile1.tilesetId === tile2.tilesetId;

    const testSeed = (x, y, verticalModifier) =&gt; {
        const newY = y + verticalModifier;
        if (newY &gt;= 0 &amp;&amp; newY &lt; area.height &amp;&amp;
            equal(getTile(area, x, newY), fillTile)) {
            if (x &lt;= 0 ||
                !equal(getTile(area, x - 1, newY), fillTile) ||
                !equal(getTile(area, x - 1, y), fillTile)) {
                seeds.push({ x, y: newY });
            }
        }
    };

    const appliedPositions = new Set();
    const positionToIndex = pos =&gt; pos.y * area.width + pos.x;

    const newTiles = [...area.tiles];

    do {
        const seed = seeds[0];
        let { x: lx, y: ly } = seed;

        if (appliedPositions.has(positionToIndex(seed))) {
            seeds.splice(0, 1);
            continue;
        };

        do {
            positions.push({ x: lx, y: ly });
            testSeed(lx, ly, 1);
            testSeed(lx, ly, -1);
            lx++;
        } while (lx &lt; area.width &amp;&amp; equal(getTile(area, lx, ly), fillTile));

        lx = seed.x;
        ly = seed.y;
        while (lx &gt; 0 &amp;&amp; equal(getTile(area, lx - 1, ly), fillTile)) {
            lx--;
            positions.push({ x: lx, y: ly });
            testSeed(lx, ly, 1);
            testSeed(lx, ly, -1);
        }

        seeds.splice(0, 1);
        positions.forEach(position =&gt; {
            appliedPositions.add(positionToIndex(position));

            const newTile = getTilingTileData(
                fillArea, x, y, position.x, position.y
            );
            const index = getTileIndex(area, position.x, position.y);
            newTiles[index] = { ...newTile };
        });
        positions = [];
    } while (seeds.length &gt; 0);

    return createTileArea(area.width, area.height, newTiles);
}

function inRange(area, x, y, width = 1, height = 1) {
    return !(x &lt; 0 || x &gt;= area.width ||
        y &lt; 0 || y &gt; area.height ||
        width &lt;= 0 || x + width &gt; area.width ||
        height &lt;= 0 || y + height &gt; area.height
    );
}

function emptyTile() {
    return {
        tileId: -1, tilesetId: -1
    };
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.3)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
