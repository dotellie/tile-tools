<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/tilearea.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
<link data-ice="userStyle" rel="stylesheet" href="user/css/0-style.css">
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/magnonellie/dtile-tilemap" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/mapObject.js~MapObject.html">MapObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/propertyObject.js~PropertyObject.html">PropertyObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/tile.js~Tile.html">Tile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/tilearea.js~TileArea.html">TileArea</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/tilelayer.js~TileLayer.html">TileLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/tilemap.js~TileMap.html">TileMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/tileset.js~TileSet.html">TileSet</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/tilearea.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { Tile } from &quot;./tile&quot;;

import { EventEmitter } from &quot;./event&quot;;

/**
 * A tile area object with a size and tiles.
 */
export class TileArea extends EventEmitter {
	/**
	 * TileArea constructor.
	 *
	 * @param {number} width - {@link TileArea#width}
	 * @param {number} height - {@link TileArea#height}
	 * @param {Tile[]} tiles - {@link TileArea#tiles}
	 */
	constructor(width, height, tiles) {
		super();

		/** The width of the tile area.
		 * @type {number} */
		this.width = width;
		/** The height of the tile area.
		 * @type {number} */
		this.height = height;

		/** The tiles in the tile area
		 * @type {Tile[]} */
		this.tiles = tiles.map(tile =&gt; {
			if (!(tile instanceof Tile)) {
				throw new TypeError(&quot;All tiles in a TileArea has to be of the Tile type.&quot;);
			}
			return tile;
		});

		if (this.width * this.height !== this.tiles.length) {
			throw new RangeError(&quot;The width and height doesn&apos;t match the amount of tiles given.&quot;);
		}
	}

	/**
	 * Gets the index of a tile in the tile array from a position.
	 *
	 * @param {number} x - The x coordinate of the tile.
	 * @param {number} y - The y coordinate of the tile.
	 *
	 * @returns {number} The index of the tile in the main array.
	 */
	getTileIndex(x, y) {
		if (!this._inRange(x, y)) {
			throw new RangeError();
		}
		return y * this.width + x;
	}

	/**
	 * Gets the tile at a position.
	 *
	 * @param {number} x - The x coordinate of the tile.
	 * @param {number} y - The y coordinate of the tile.
	 *
	 * @returns {Tile} The tile at the provided position.
	 */
	getTile(x, y) {
		return this.tiles[this.getTileIndex(x, y)];
	}

	/**
	 * Gets an area of tiles.
	 *
	 * @param {number} x - The x coordinate of the tile area.
	 * @param {number} y - The y coordinate of the tile area.
	 * @param {number} width - The width of the tile area.
	 * @param {number} height - The height of the tile area.
	 *
	 * @returns {TileArea} A {@link TileArea} of the area requested.
	 */
	getTileArea(x, y, width, height) {
		if (!this._inRange(x, y, width, height)) {
			throw new RangeError();
		}
		const tiles = [];
		for (let ly = y; ly &lt; y + height; ly++) {
			for (let lx = x; lx &lt; x + width; lx++) {
				tiles.push(this.getTile(lx, ly));
			}
		}
		return new TileArea(width, height, tiles);
	}

	/**
	 * Gets tiling data from this TileArea.
	 *
	 * Most of the time when mapping tilemaps, having the pen be &quot;tiling&quot; is more
	 * useful than having it overwrite everywhere. This function is meant to provide
	 * that kind of functionallity.
	 *
	 * @param {number} originX - The x coordinate to tile from.
	 * @param {number} originY - The y coordinate to tile from.
	 * @param {number} x - The x coordinate to get data from.
	 * @param {number} y - The y coordinate to get data from.
	 *
	 * @returns {Tile} The calculated tile.
	 */
	getTilingTileData(originX, originY, x, y) {
		const tileX = ((x - originX) % this.width + this.width) % this.width;
		const tileY = ((y - originY) % this.height + this.height) % this.height;

		return this.getTile(tileX, tileY).clone();
	}

	/**
	 * Inserts a TileArea into this TileArea.
	 *
	 * This isertion does not fail if it goes outside of the TileArea.
	 *
	 * @param {number} x - Top left x coordinate of where the TileArea should be inserted.
	 * @param {number} y - Top left y coordinate of where the TileArea should be inserted.
	 * @param {TileArea} tileArea - The TileArea to be inserted.
	 * @param {boolean} skipEmpty - If the insertion should skip empty (-1) tiles.
	 */
	insertTileArea(x, y, tileArea, skipEmpty) {
		for (let lx = x; lx &lt; x + tileArea.width; lx++) {
			for (let ly = y; ly &lt; y + tileArea.height; ly++) {
				try {
					const newTile = tileArea.getTile(lx - x, ly - y);
					if (skipEmpty &amp;&amp; newTile.tileId === -1) continue;

					this.getTile(lx, ly).setData(newTile.tileId, newTile.tilesetId);
				} catch (e) {
					if (e instanceof RangeError) continue; else throw e;
				}
			}
		}
	}

	/**
	 * Fills an area (think bucket tool in GIMP).
	 *
	 * @param {number} x - The x coordinate of where to fill from.
	 * @param {number} y - The y coordinate of where to fill from.
	 * @param {TileArea} tileArea - The TileAre to fill with (tiling).
	 */
	fillAt(x, y, tileArea) {
		let positions = [];

		const fillTile = this.getTile(x, y).clone();
		const seeds = [{ x, y }];

		const testSeed = (x, y, verticalModifier) =&gt; {
			const newY = y + verticalModifier;
			if (newY &gt;= 0 &amp;&amp; newY &lt; this.height &amp;&amp;
				this.getTile(x, newY).tileId === fillTile.tileId) {
				if (x &lt;= 0 ||
					this.getTile(x - 1, newY).tileId !== fillTile.tileId ||
					this.getTile(x - 1, y).tileId !== fillTile.tileId) {
					seeds.push({ x, y: newY });
				}
			}
		};

		const appliedPositions = new Set();
		const positionToIndex = pos =&gt; pos.y * this.width + pos.x;

		do {
			const seed = seeds[0];
			let { x: lx, y: ly } = seed;

			if (appliedPositions.has(positionToIndex(seed))) {
				seeds.splice(0, 1);
				continue;
			};

			do {
				positions.push({ x: lx, y: ly });
				testSeed(lx, ly, 1);
				testSeed(lx, ly, -1);
				lx++;
			} while (lx &lt; this.width &amp;&amp; this.getTile(lx, ly).tileId === fillTile.tileId);

			lx = seed.x;
			ly = seed.y;
			while (lx &gt; 0 &amp;&amp; this.getTile(lx - 1, ly).tileId === fillTile.tileId) {
				lx--;
				positions.push({ x: lx, y: ly });
				testSeed(lx, ly, 1);
				testSeed(lx, ly, -1);
			}

			seeds.splice(0, 1);
			positions.forEach(position =&gt; {
				appliedPositions.add(positionToIndex(position));

				const { tileId, tilesetId } = tileArea.getTilingTileData(
					x, y, position.x, position.y
				);
				this.getTile(position.x, position.y).setData(tileId, tilesetId);
			});
			positions = [];
		} while (seeds.length &gt; 0);
	}

	/**
	 * Resizes the TileArea, inserting empty tiles if grown and removing tiles if shrunk.
	 *
	 * Keep in mind that this function is currently really slow. It works, but it&apos;s just
	 * very slow. Just ping me or send a PR if you need it to be faster. For now
	 * though, don&apos;t call it every frame, but rather once you&apos;re certain you need
	 * to resize.
	 *
	 * @param {number} width - The new width of the TileArea.
	 * @param {number} height - The new height of the TileArea.
	 */
	resize(width, height) {
		// Shrink
		if (width &lt; this.width) {
			this.tiles = this.getTileArea(0, 0, width, this.height).tiles;
			this.width = width;
		}
		if (height &lt; this.height) {
			this.tiles = this.getTileArea(0, 0, this.width, height).tiles;
			this.height = height;
		}

		// Grow
		if (width &gt; this.width) {
			let offset = 0;
			for (let y = 0; y &lt; this.height; y++) {
				const startIndex = this.getTileIndex(this.width - 1, y) + offset + 1;
				for (let x = 0; x &lt; width - this.width; x++) {
					this.tiles.splice(startIndex + x, 0, new Tile());
					offset++;
				}
			}
			this.width = width;
		}
		if (height &gt; this.height) {
			let offset = 0;
			for (let y = this.height; y &lt; height; y++) {
				const startIndex = this.getTileIndex(this.width - 1, this.height - 1) + offset + 1;
				for (let x = 0; x &lt; this.width; x++) {
					this.tiles.splice(startIndex + x, 0, new Tile());
					offset++;
				}
			}
			this.height = height;
		}
	}

	_inRange(x, y, width = 1, height = 1) {
		return !(x &lt; 0 || x &gt;= this.width ||
			y &lt; 0 || y &gt; this.height ||
			width &lt;= 0 || x + width &gt; this.width ||
			height &lt;= 0 || y + height &gt; this.height
		);
	}
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
